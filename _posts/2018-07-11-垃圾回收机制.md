---
layout: post
title: 垃圾回收机制
key: JVM
mathjax: true
mathjax_autoNumber: true
---
## 垃圾回收机制
常用的垃圾回收器及特点如下图所示。

<img src="https://github.com/Jesuslittlebug/jesuslittlebug.github.io/blob/master/images/GC.png?raw=true"/>

### 垃圾回收算法

- 标记-清除算法
  
  其算法分为“标记”和“清除”连个阶段：
  1. 首先标记内存中所有需要回收的对象
  2. 清除，在标记完成后统一回收被标记的对象。
  
  不足：
   
   - 两个阶段的效率都不高
   - 清除后导致不连续的内存碎片，当碎片太多时，分配对象时找不到连续的内存空间，从而提前触发垃圾收集动作。

- 复制算法

  为解决效率问题，复制算法横空而出。
  
  1. 其将内存空间划分为大小相等的空间，每次只使用其中的一块（**对应于Eden和From/To Survivor空间，其并不是等分的**）
  2. 当这块内存用完（**Eden+一块Survivor空间**）后，将存活的对象复制到另一块空间上（**另一块Survivor空间**）
  3. 然后清理掉已使用的内存空间（**Eden+一块Survivor空间**）。
  
  这样就不用考虑碎片的问题了。若Survivor空间没有足够的空间，就将对象移动到老年代中。
  
- 标记-整理算法

  在对象存活率高时，会产生较多的复制，新生代朝生夕死，存活对象较少，比较适合复制算法。
  
  而老年代中存活率高，不使用复制算法，因此使用标记-整理算法。其与标记清除算法不同的是，标记完之后不进行清理，而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。
  
