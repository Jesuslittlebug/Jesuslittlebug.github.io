---
layout: post
title: JVM内存模型
key: JVM
mathjax: true
mathjax_autoNumber: true
---

## JVM内存模型
相较于C++而言，开发者不再需要手动去管理内存，且Java应用能够实现跨平台，这完全得益于Java 虚拟机（Java Virtual Machine）的使用。

Java虚拟机负责每一个对象的生命周期，对开发者透明，减少了内存泄漏与溢出的概率，但是开发者还是需要了解虚拟机是如何使用内存的，这样在出现了内存错误的时候才能够去排查错误。

JVM运行时数据区分为线程私有（隔离）与线程共享的区域，其中线程私有的有**程序计数器、本地方法栈、虚拟机栈**，线程共享的分为**方法区和堆。**

线程私有即是指，每条线程在各自的区域里运行，互不干扰。

线程共享区域即是指，所有的线程共享一块内存区。
<!--more-->

### 1. 程序计数器
多线程在执行时是通过轮流切换并分配处理器执行时间来实现的，因此在任何一个确定的时刻，一个处理器或者是一个内核都只会执行一条线程，那么去记录线程执行到了何处并进行恢复呢，这就需要每条线程都有一个独立的程序计数器，各个线程之间互不影响，独立存储。

程序计数器是一块较小的内存空间，记录了当前线程执行的字节码的行号。

若线程执行的是Java方法，那么计数器记录的是正在执行的虚拟机字节码指令的地址

若执行的是Native方法，则计数器为空。

此内存区域是唯一没有规定任何OutOfMemoryError情况的区域。

### 2. java虚拟机栈

虚拟机栈也是线程私有的，生命周期与线程一致，其描述的是Java方法执行的内存模型。

每个方法在执行的同时会创建一个**栈帧**，存储的是**局部变量表、操作数栈、动态链接、方法出口**等信息，每一个方法从调用到执行完成，都是一个栈帧在虚拟机栈中进栈到出栈的过程。

我们主要关注局部变量表，局部变量表中存储着编译期可知的各种**基本数据类型**（int,double,float,char,byte,boolean,short）、**对象引用**（reference类型，并不是对象，可能是指向对象起始地址的引用指针，也可能是指向一个对表对象的句柄）和**returnAddress类型**（指向了一条字节码指令的地址）

线程请求深度超过了虚拟机栈的深度抛出StackOverflowError异常。

若虚拟机栈可动态扩展，无法申请到足够内存时，抛出
OutOfMemoryError异常。

### 3. 本地方法栈
其也是私有的，与虚拟机栈作用类似，但是其是为虚拟机使用到的Native方法服务。

其也会抛出StackOverflowError和OutOfMemoryError异常。

### 4. Java堆
我们知道java是面向对象语言，所有的实体都会抽象为一个类，类为不同的实体创建对象。这些对象创建出来后都存储在Java堆中，其是内存中最大的一块，被所有的线程共享的区域。

一般而言所有的对象实例以及数组都是分配在Java堆上的，但是随着JIT编译器的发展，其也不是那么绝对了。

<img src="https://github.com/Jesuslittlebug/jesuslittlebug.github.io/blob/master/images/Java%E5%A0%86.jpg?raw=true" title="Java堆空间"/>


- 对象优先分配在Eden空间，当没有足够空间时，则会发生一次Minor GC（新生代垃圾回收），在gc时会将存活的对象放入到From/To Survivor其中一个空间中。新生代使用的是复制收集算法，为提高内存利用率，每次只使用其中的一个Survivor空间。

- 若Survivor能放下存活对象，则对新生代空间进行回收。

- 若Survivor放不下存活的对象，则通过分配担保机制提前转移到老年代中。

- 除了在无法分配时会晋升到老年代以外，也可通过设置参数**-XX：PretenureSizeThrehold**来使得大对象直接在老年代分配，从而避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法收集内存）。

- 长期存活的对象也会进入老年代，在Survivor空间每经历一次Minor GC，其年龄就增加一岁，当增加到一定的程度（默认为15岁），将晋升到老年代。可以通过参数**-XX：MaxTenuringThrehold**来设置年龄阈值。

- 若在Survivor空间中相同年龄的对象大小超过了Survivor空间的一半时，年龄大于或等于该年龄的对象可直接进入老年代。无需等到**MaxTenuringThrehold**的中要求的年龄。

当堆中没有足够的内存来完成实例分配时，且堆无法扩展是，将会抛出OutOfMemoryError异常。

### 5. 方法区
方法区与Java堆一样都是各个线程共享的内存区域，用于存储**已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码**等数据。

当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常。

- 运行时常量池
  其是方法区的一部分。class文件除了有类的版本、字段、方法、接口等信息外，还有一项信息就是常量池，用于存放编译器生成的各种字面量和符号引用，其会在类加载后进入方法区的运行时常量池中。
  
  当常量池无法再申请到内存时同样会抛出OutOfMemoryError异常。
  
  
### 6. 直接内存
直接内存不属于虚拟机运行时数据区的一部分，也不是java规范定义的内存区域。

这块内存属于本机物理内存的范畴，不受Java堆大小的限制。

当使用NIO类中的通道（Channel）或缓冲区（Buffer）的I/O方式，可以使用Native函数直接分配堆外内存，然后通过Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。

PS：在配置堆内存大小时，不要忘记直接内存的存在。若使得各个内存区域总和大于物理内存的限制，就会使得动态扩展时产生OutOfMemoryError异常。

