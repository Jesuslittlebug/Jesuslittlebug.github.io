---
layout: post
title: 单例序列化及反射不一致问题
key: szk
tags: 设计模式
---

## 反射
通过利用反射，获取类的构造函数，从而直接生成一个类的实例，从而使得内存中存在两个实例，且这两个实例不一致。这在单例中是不可以的。
## 序列化
当类实现了Serializable或Externalizable接口，在当实例序列化后，再读取出来后，就与之前的实例不一致了。
如何去避免这种问题呢，参阅以下的代码及注释。
## 示例代码
```java
public class Singleton implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private Singleton() {
		
	}

	/*
	 * 去除本段注释，用来解决通过反射直接生成实例，从而导致存在多实例的问题。
	 * 在高并发下，可以考虑用volatile关键字或者是atomicboolean。
	 * private static boolean flag = true;
	private Singleton() {
		if(flag) {
			flag = false;
			System.out.println("初始化单例");
		}else {
			throw new RuntimeException("已经存在一个实例了");
		}
		
	}*/

	private static class SingletonHolder {
		public static Singleton INSTANCE = new Singleton();
	}

	public static Singleton getSingletonInstance() {
		return SingletonHolder.INSTANCE;
	}

	/*
	 * 去除掉本段注释，可以解决序列化导致的单例不一致问题
	 * private Object readResolve() { return getSingletonInstance(); }
	 */

	public static void main(String[] args) {
		Singleton signleTon = Singleton.getSingletonInstance();

		String filePath = "f:" + File.separator + "singleton.dat";
		// 对象序列化，存储到dat文件
		try (OutputStream outputStream = new FileOutputStream(filePath);
				ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream)) {

			objectOutputStream.writeObject(signleTon);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		Singleton serialSingleTon = null;
		// 反序列对象，从dat文件中读入对象。
		try (InputStream inputStream = new FileInputStream(filePath);
				ObjectInputStream objectInputStream = new ObjectInputStream(inputStream)) {

			serialSingleTon = (Singleton) objectInputStream.readObject();
		} catch (IOException | ClassNotFoundException e) {
			e.printStackTrace();
		}

		System.out.println("序列化测试,两个单例是否相等:" + (serialSingleTon == signleTon));

		//通过反射生成对象实例
		try {
			Constructor<? extends Singleton> constructor = signleTon.getClass().getDeclaredConstructor();
			constructor.setAccessible(true);
			System.out.println("反射测试，两个单例是否相等:" + (signleTon == (Singleton) constructor.newInstance()));
		} catch (NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException
				| IllegalArgumentException | InvocationTargetException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
```
## 枚举方式
实现单例模式，除了饿汉式、懒汉式、doublecheck以及静态内部类等方法外，还有一种是通过枚举的方式实现。枚举的方式，其本身就已经可以保证了序列化与反射后的实例都是一致的。
