---
layout: post
title: 重构代码基础
key: szk
tags: 重构代码
mathjax: true
mathjax_autoNumber: true
---

## 重构的目的
重构是在保证系统现有前提下，提高系统的质量或者降低开发成本，从而使系统更有价值。其要解决具有以下特征从而使得代码难以修改的问题：

- 难以阅读的程序
- 逻辑重复的代码
- 添加新行为时需修改已有代码的程序
- 带有复杂条件逻辑的程序

## 重构的难点
虽然提倡重构，但是也应该在过程中时时监控其过程，从而避免重构引入无法发现的新问题。

### 1.数据库
最经常出现问题的就是数据库，程序与数据库结构耦合紧密，使得数据库结构难以修改。

非对象数据库中，可以通过在对象模型和数据库模型中添加一层分隔层，隔离两个模型各自的变化。分层会增加系统复杂度，但是会增加灵活度。在有多个数据库或数据库模型复杂到难以控制时，即使不重构，也提倡分层。

关于数据库重构的相关问题可以参阅《数据库重构》这本书。
### 2.修改接口
当接口被对外发布并被调用后，在对接口进行重构，就需要考虑到所有调用者，进行兼容。

若重构修改了已发布的接口，就需要同时维护新旧两套接口，直到所有的调用者完成了迁移。**建议在旧接口中调用新接口，并标示旧接口为deprecated**。Java容器类的兼容就是很好的例子。

<!-- more -->
### 3.难以通过重构完成的设计改动
可能会出现某些核心设计方案无法以重构的方式修改。这就要求在设计阶段下，先想象重构的情况，评估候选设计方案在重构为另一种设计的难度，选取最简单的设计方案。若预先看不到简单的重构方法，那就多在设计上投入精力。
### 4.何时不重构
- 相对于重构而言，重写一套代码更简单时。
- 项目接近最后期限的时候，也应避免重构。

## 何时重构
对于何时进行重构并没有一个精确的衡量标准，更多的是依赖有经验的开发人员的直觉。但是依然有迹可循，下面这些坏味道会帮助你决定是否进行重构，此外也要培养自己的判断力，比如一个类中有多少实例变量算大，一个函数中代码有多长算长。

下面描述了一些代码的坏味道，可理解为需要进行重构的代码的特性。
### 1.Duplicated Code（重复代码）
首当其冲的是重复代码，会有以下三种情况。

- 同一个类的两个函数含有相同的表达式。
- 两个互为兄弟的子类内含有相同表达式。
- 两个毫不相干的类出现重复代码。

### 2.Long Method（过长函数）
积极地分解函数。

**原则：每当感觉需要以注释来说明点什么时，就可以将需要说明的东西写进一个独立函数中。**

除了注释是一个提炼代码的信号，条件表达式和循环也是一个提炼信号。注意要给提炼出的独立函数设置一个易于理解函数用途的名称。

### 3.Large Class（过大的类）
当类中出现太多的实例变量，重复代码也有可能会有很多。
可以考虑将几个变量或代码提炼到新的类中。

### 4.Long Parameter List（过长参数列）
函数所需的东西都要以参数的形式传递进去，但是在面向对象程序中，其参数列通常会比较短。

### 5.Divergent Change（发散式变化）
发散式变化是说某个类经常因为不同的原因在不同的方向上发生变化，**即一个类受多种变化影响**。应该让类具有这样的特性，针对某一外界变化的所有修改应尽量发生在单一类中。

说的应该是类设计时的单一职责问题。

比如：有一个类，当新加入一个数据库时，需修改这个类，新出现一个工具时，也要修改这个类。在同一类中发生朝着不同方向的=变化，这就是发散式变化，因此可以考虑将类拆分。使用Extract Class。

### 6.Shotgun Surgery（霰弹式修改）
与上面恰恰相反，遇到某种变化，需要在多个类中作出小修改，这就是霰弹式修改。修改的代码遍布各处，即：**一个变化引发多个类修改。**

考虑使用Move Method 和 Move Field 将所有需修改的代码放进一个类，若没有合适的类则创建一个。**通常是运用Inline Class（内联类） 将一系列相关行为放进同一个类。**

### 7.Feature Envy(依恋情结)
其是指处于一个类中函数为了处理某个事情调用了很多另一个类实例的函数。应使用Move Method 将函数放到被调用类中。

当一个函数调用多个类功能时，如何决定函数放在哪里呢？**原则就是，判断哪个类拥有最多被此函数使用的数据，然后将这个函数和数据放在一起。**

### 8.Data Clumps（数据泥团）
常常会在很多地方看到相同的三四项数据：两个类中相同的字段、许多函数签名中相同的参数。

找出这些数据以字段形式出现的地方，运用Extract Class将它们提炼到一个独立对象中。然后运用Introduce Parameter Object 或 Preserve Whole Object 为函数削减参数列，即用对象代替参数。

**不必在意Data Clumps只用上新对象的一部分字段，只要新对象能取代两个以上字段就够了。**

### 9.Primitive Obsession（基本类型偏执）
基本类型偏执就是说在任务中不运用小对象-像结合数值和币种的money类、由起始值和结束值组成的range类、电话号码或邮编等特殊字符串。

可以运用Replace Data Value with Object将原本单独存在的数据值替换为对象。比如order类中的customer字段就应该是个对象。

当要替换的数据值是类型码，且其不影响宿主类行为（不会在switch等语句中出现），则可以运用Replace Type Code with Class。像Person类中的血型，就可以将血型封装为一个类。

当与类型码相关的表达式时，则运用Replace Type Code with Subclass 或 Replace Type Code with State/Strategy进行处理。

##### Replace Type Code with Subclass（子类取代类型码）
一般情况下，在出现了检查类型码值并根据值的不同去执行不同的动作时，应使用Replace Condition with Polymorphism进行重构。为保证重构的顺利进行，应先将类型码替换为可拥有多态行为的继承体系。
**Replace Type Code with Subclass就是为了建立这样的继承体系。**

- 为类型码创建set/get函数。若类型码被传递给构造函数，则将构造函数换成工厂函数。
- 为每个类型码建立一个相应的子类，子类中覆写类型码的取值函数，返回相应的类型码。
- 删除父类中的保存类型码的字段，将类型码访问函数声明为抽象函数。

示例：

```java
//原始类
class Employee{
private int type;
private static final int DEVELOPER = 0;
private static final int Manager = 1;

public Employee(int type){
	this.type = type;
}	

//利用这条规则重构后的父类
abstract class Employee{
	abstract int getType();
	static Employee creat(int type){
		switch(type){
			case 0: return new Developer();
			....
		}
	}
}
class Developer extends Employee{
	int getType(){
		return 0；
	}
}

```
在以下两种情况下，你不能使用这条规则:

- 类型码值在创建对象后发生了改变
- 类型码宿主类已经有了子类。

面对以上两种情况时，需要使用Replace Type Code with State/Strategy。

### 10.Switch Statements（switch 惊悚现身）
面向对象的一个最明显的特征就是少用switch/case语句。在碰到有switch语句时，就应该考虑以多态来替换它。


